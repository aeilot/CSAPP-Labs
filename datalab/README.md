用 AI 生成一个 writeup

TL;DR: 这份 `bits.c` 实验的核心经验是强迫你深入理解整数（补码）和浮点数（IEEE 754）在二进制层面的表示方法。你通过使用一组极其受限的位运算符（如 `~`, `&`, `|`, `^`, `+`, `<<`, `>>`）来实现复杂的逻辑、算术、比较和类型转换操作，从而真正掌握了位运算的技巧。

---

## 1. 整数与补码 (Integer & Two's Complement)

你实现的大部分整数函数都依赖于对32位补码的深刻理解。

* **基本运算的重新实现**:
    * `negate`: `~x + 1` 是补码取反的标准定义。
    * `bitXor`: 你的实现 `~((~(x&~y))&(~((~x)&y)))` 本质上是利用德摩根定律。`~(A & B)` 等于 `~A | ~B`。你的代码可以被分解为 $(x \land \neg y) \lor (\neg x \land y)$，这正是 XOR 的定义。这表明任何逻辑运算都可以只用 `~` 和 `&` (或 `~` 和 `|`) 构建。

* **掩码 (Masking) 与隔离**:
    * `allOddBits`: 你通过 `0xAAAAAAAA` 这个掩码来隔离出所有奇数位。然后通过 `(x & b) - b` 并检查结果是否为0，来判断这些位是否全为1。
    * `conditional`: 这是三元运算符 `x ? y : z` 的经典实现。关键在于 **如何将一个布尔值（0或非0）转换成一个全0或全-1的掩码**。
        1.  `!(!x)`: 将任意非0值转为1，0还是0。
        2.  `~xb + 1`: 将 1 转为 -1 (即 `0xFFFFFFFF`)，将 0 还是转为 0。
        3.  `(M & y) | (~M & z)`: 利用这个掩码 `M` (全1或全0) 来选择 `y` 还是 `z`。

* **算术移位与符号位**:
    * `isAsciiDigit`: 你通过 `(a - b) >> 31` 来判断 $a \ge b$ 还是 $a < b$。如果 $a-b$ 为负，算术右移31位会得到 -1 (全1)；如果为非负，则得到 0。`!` 运算符再将其反转为1（表示 "大于等于"）。你用这个技巧两次来实现范围检查 $[0\times30, 0\times39]$。
    * **一个重要陷阱**: 你的 `isLessOrEqual` 实现 `!((y-x)>>31)` 简洁明了，但它在 $x$ 和 $y$ 符号不同且计算 `y-x` 导致 **算术溢出** 时会失败（例如 $x=T_{\min}$, $y=T_{\max}$）。这是这个 lab 中一个著名的陷阱，完整的解法需要先检查 $x$ 和 $y$ 的符号位。

* **利用特殊值和溢出**:
    * `tmin`: `1 << 31` 直接构造了最小负数 $T_{\min}$ (`0x80000000`)。
    * `isTmax`: 你的解法 `~(x+1+x)` 利用了 $T_{\max} + 1 = T_{\min}$ 和 $T_{\max} + T_{\min} = -1$ (`0xFFFFFFFF`) 的特性。`~(T_{\max} + T_{\min})` 结果为 `0`。同时，`x = -1` 时 `~(x+1+x)` 也为0，所以你用 `!!(x+1)` (即 `x != -1`) 来排除这种情况。
    * `logicalNeg`: `((x >> 31) | ((-x) >> 31)) + 1` 是一个非常巧妙的技巧。对于任何非0数 $x$， $x$ 和 $-x$ 中至少有一个是负数（$T_{\min}$ 比较特殊，它和它的相反数都是负数），所以 `(x >> 31) | ((-x) >> 31)` 的结果必为 -1。而当 $x=0$ 时，结果为 0。最后 `+1` 将 -1 映射到 0，0 映射到 1。

* **位上的二分搜索**:
    * `howManyBits`: 这个函数是技巧的集大成者。
        1.  `x = ((~fg) & x) | (fg &(~x))` (其中 `fg = x>>31`)：这行代码等价于 `x = (x >= 0) ? x : ~x`。它将问题统一了：对于正数，我们找最高位的1；对于负数，我们找最高位的0（取反后还是找最高位的1）。
        2.  `h16 = !!(x >> 16) << 4`: 这是一个 **位上的二分搜索**。它检查高16位是否有1。如果有，`h16` 记为16，然后 `x >>= h16` 将 `x` 移位，使得我们接下来只用处理剩下的16位。
        3.  `h8`, `h4`, `h2`, `h1`, `h0`... 一直重复这个过程。
        4.  `... + 1`: 最后的 `+1` 是为符号位本身腾出空间。

---

## 2. 浮点数 (Floating Point)

浮点数部分要求你手动解析和构造 IEEE 754 单精度浮点数。

* **核心: 理解三种表示法**: 所有三个函数都基于对 `s` (1位符号), `exp` (8位指数), `ff` (23位小数) 的解析，以及它们如何构成三种类型的值：
    1.  **特殊值 (Special)**: `exp == 0xFF` (NaN 或 $\infty$)。
    2.  **非规格化 (Denormalized)**: `exp == 0`。值为 $V = (-1)^s \times 0.f \times 2^{1 - 127}$。
    3.  **规格化 (Normalized)**: `0 < exp < 0xFF`。值为 $V = (-1)^s \times 1.f \times 2^{exp - 127}$。

* **`floatScale2` (乘以 2)**:
    * 处理 Denorm 时，乘以 2 等于左移小数位 `ff <<= 1`。你需要检查左移后是否导致 "溢出" 到规格化数（即 `ff` 的第23位是否变成了1）。
    * 处理 Norm 时，乘以 2 等于指数 `exp++`。你需要检查 `exp` 是否溢出到了 `0xFF` (变为 $\infty$)。

* **`floatPower2` (计算 $2.0^x$)**:
    * 这是 `floatScale2` 的逆向工程。你需要根据整数 $x$ 的范围来 *构造* 合适的浮点数。
    * $x > 127$: 溢出为 $\infty$ (`exp = 0xFF, ff = 0`)。
    * $-126 \le x \le 127$: 规格化数。`exp = x + 127`, `ff = 0`。
    * $-149 \le x < -126$: 非规格化数。`exp = 0`, `ff` 是一个单独的1，其位置由 `x` 决定 ( `ff = 1 << (x + 149)` )。
    * $x < -149$: 下溢为 0。

* **`floatFloat2Int` (浮点转整数)**:
    * 计算真实指数 `E = exp - 127`。
    * `E < 0`: 浮点数 $< 1$，截断为 0。
    * `E \ge 31`: 浮点数太大（或 $T_{\min}$），溢出。这是最难处理的边界情况，需要返回 `0x80000000u`。
    * `0 \le E < 31`: 核心转换。
        1.  `ff = ff | (1 << 23)`: 重新插入规格化数隐藏的 `1`。
        2.  `if (E < 23)`: `E` 较小，说明小数点在23位小数中间。右移 `(23 - E)` 位来丢弃小数部分。
        3.  `else`: `E` 较大，说明小数点在23位小数右侧。左移 `(E - 23)` 位来乘以 $2$ 的相应次方。
        4.  最后根据符号位 `s` 决定是否取反。
